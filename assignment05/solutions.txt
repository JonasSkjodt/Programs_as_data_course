5.1 
The F# merge function was created in the chap5.fsx file (see image ex5.1.png for results)
The java merge method was created in LinkedList.java and its results printed from main

5.7
We changed TypL to accept a list in TypedFun/TypedFun.fs
and then wondered what to do

6.1
we added our solutions as comments above the tests in ParseAndRunHigher.fs from line 63 to 95. (revise this later)

6.2
We added Fun of string * expr to Absyn
Then we added  | "->"            { ARROW } to FunLex.fsl

To FunPar.fsy we added

    %token FUN ARROW

and 

    | FUN NAME ARROW Expr                 { Fun($2, $4)            }

we then changed eval to accept Fun(x, body) and tested it with test2 and test3 in HigherFun.fs.
See image ex6_2_1.png and ex6_2.png for results


6.3
See image ex6_3 for results

6.4

6.5

(1)
inferType (fromString "let f x = 1 in f f end");;
Works fine, gives type int back. It has a val it: string = "int"

(2)
inferType (fromString "let f g = g g in f end");;
type error: circularity
circularity: function parameter g cannot be applied to itself

(3)
inferType (fromString "let f x = let g y = y in g false end in f 42 end");;
Works fine, gives type bool back. It has a val it: string = "bool"

(4)
inferType (fromString "let f x = let g y = if true then y else x in g false end in f 42 end");;
System.Exception: type error: bool and int
There's a conflict because it expects to have the same return type.
From the code above, it has a chance to return a bool or an int, which results in an error.


(5)
inferType (fromString "let f x = let g y = if true then y else x in g false end in f true end");;
Works fine, gives type bool back. It has a val it: string = "bool"


6.5.2
Remember that the type arrow (->) is right associative, so int -> int -> int is the same as
int -> (int -> int), and that the choice of type
variables does not matter, so the type scheme ’h -> ’g -> ’h is the same
as a’ -> ’b -> ’a.

example:
> let mul2 y = 2 * y;;
val mul2: y: int -> int


• bool -> bool
inferType (fromString "let f y = true = y in f end");;
val it: string = "(bool -> bool)"

• int -> int
inferType (fromString "let f y = 2 * y in f end");;
val it: string = "(int -> int)"

• int -> int -> int
inferType (fromString "let f y = let g x =  x * y in g end in f end");;
val it: string = "(int -> (int -> int))"

• ’a -> ’b -> ’a
inferType (fromString "let f y = let g x =  if true then y else y in g end in f end");;
val it: string = "('h -> ('g -> 'h))"

• ’a -> ’b -> ’b
inferType (fromString "let f y = let g x =  if true then x else x in g end in f end");;
val it: string = "('g -> ('h -> 'h))"

• (’a -> ’b) -> (’b -> ’c) -> (’a -> ’c)
inferType (fromString "let f y = let g x =  if true then x else x in g end in f end");;


• ’a -> ’b

• ’a



old examples
inferType (fromString "let f y = let g x =  x * y in g end in f end");;
val it: string = "(int -> (int -> int))"