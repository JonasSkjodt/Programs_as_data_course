Exercise 3.3 Write out the rightmost derivation of the string below from the expression grammar at the end of
Sect. 3.6.6, corresponding to ExprPar.fsy. Take note of the sequence of grammar rules (Aâ€“I) used.

let z = (17) in z + 2 * 3 end EOF

Example from 3.6.6
Main ::= Expr EOF rule A
Expr ::= NAME rule B
    | CSTINT rule C
    | MINUS CSTINT rule D
    | LPAR Expr RPAR rule E
    | LET NAME EQ Expr IN Expr END rule F
    | Expr TIMES Expr rule G
    | Expr PLUS Expr rule H
    | Expr MINUS Expr rule I


Note:

Which way is the optimal way of writing exercise 3.3? we've left two ways of doing it beneath and assigned it 3.3.1 and 3.3.2
(our answer is 3.3.1, but we've left 3.3.2 up)

3.3.1:

Main
Expr EOF                                            (Rule A)
Expr TIMES Expr                                     (Rule G)
Expr TIMES CSINT 3                                  (Rule C)
CSINT 2 TIMES CSINT 3                               (Rule C) 
Expr PLUS CSINT 2 TIMES CSINT 3                     (Rule H)
LPAR Expr RPAR PLUS CSINT 2 TIMES CSINT 3           (Rule E)
LPAR CSINT 17 RPAR PLUS CSINT 2 TIMES CSINT 3       (Rule C)
LET Expr IN NAME z PLUS CSINT 2 TIMES CSINT 3 END   (Rule F)
LET NAME z IN NAME z PLUS CSINT 2 TIMES CSINT 3 END (Rule B)

3.3.2:

Input                                       parse stack                                         
------------------------------------------- ---------------------------------------------- 
let z = (17) in z + 2 * 3 end EOF           Main                                 (Rule A)                                        
let z = (17) in z + 2 * 3 end               LET z EQ (17) IN z + 2 * 3 END       (Rule F)              
3                                           CSTINT                               (Rule C)    
2                                           CSTINT                               (Rule C) 
3*2                                         Expr TIMES Expr                      (Rule G)
z                                           Expr ::= NAME                        (Rule B)
z+2                                         Expr PLUS Expr                       (Rule H)
z+expr                                      Expr PLUS Expr                       (rule H)
17                                          CSTINT                               (rule C)
(17)                                        LPAR Expr RPAR                       (rule E)
z                                           Expr ::= NAME                        (rule B)



Exercise 3.4 Draw the above derivation as a tree.

Exercise 3.5 Get expr.zip from the book homepage and unpack it. Using a command prompt, generate (1) the lexer and (2) the parser for expressions by running
fslex and fsyacc; then (3) load the expression abstract syntax, the lexer and
parser modules, and the expression interpreter and compilers, into an interactive F#
session (fsi):
fslex --unicode ExprLex.fsl
fsyacc --module ExprPar ExprPar.fsy
fsi -r FSharp.PowerPack.dll Absyn.fs ExprPar.fs ExprLex.fs ^
Parse.fs
Now try the parser on several example expressions, both well-formed and ill-formed
ones, such as these, and some of your own invention:
open Parse;;
fromString "1 + 2 * 3";;
fromString "1-2- 3";;
fromString "1 + -2";;
fromString "x++";;
fromString "1 + 1.2";;
fromString "1 + ";;
fromString "let z = (17) in z + 2 * 3 end";;
fromString "let z = 17) in z + 2 * 3 end";;
fromString "let in = (17) in z + 2 * 3 end";;
fromString "1 + let x=5 in let y=7+x in y+y end + x end";;

Exercise 3.6 Use the expression parser from Parse.fs and the compiler scomp
(from expressions to stack machine instructions) and the associated datatypes from
Expr.fs, to define a function compString : string -> sinstr list
that parses a string as an expression and compiles it to stack machine code.


Exercise 3.7 Extend the expression language abstract syntax and the lexer and
parser specifications with conditional expressions. The abstract syntax should be
If(e1, e2, e3), so modify file Absyn.fs as well as ExprLex.fsl and
file ExprPar.fsy. The concrete syntax may be the keyword-laden F#/ML-style:
if e1 then e2 else e3
or the more light-weight C/C++/Java/C#-style:
e1 ? e2 : e3
Some documentation for fslex and fsyacc is found in this chapter and in Expert
F# [17].