Exercise 3.3 Write out the rightmost derivation of the string below from the expression grammar at the end of
Sect. 3.6.6, corresponding to ExprPar.fsy. Take note of the sequence of grammar rules (Aâ€“I) used.

let z = (17) in z + 2 * 3 end EOF

Example from 3.6.6
Main ::= Expr EOF rule A
Expr ::= NAME rule B
    | CSTINT rule C
    | MINUS CSTINT rule D
    | LPAR Expr RPAR rule E
    | LET NAME EQ Expr IN Expr END rule F
    | Expr TIMES Expr rule G
    | Expr PLUS Expr rule H
    | Expr MINUS Expr rule I



Answer:

let z = (17) in z + 2 * 3 end EOF

Input                                       parse stack                                         Details
------------------------------------------- ----------------------------------------------      -------------------------------------------
let z = (17) in z + 2 * 3 end EOF          Main (Rule A)                                        We looked at EOF (since we're going right to left)
let z = (17) in z + 2 * 3 end              LET z EQ (17) IN z + 2 * 3 END (Rule F) Main         We inserted the correct inputs for the expressions for understanding
3                                          LET z EQ (17) IN z + 2 * Expr (Rule C) END Main    
2                                          LET z EQ (17) IN z + Expr * Expr (Rule C) END Main
2 * 3                                      LET z EQ (17) IN z + Expr (Rule G) END Main           
z                                          LET z EQ (17) IN Expr (Rule B) + Expr END Main
z + Expr                                   LET z EQ (17) IN Expr (Rule H) END Main
(17)                                       LET z EQ Expr (Rule E) IN Expr END Main
z                                          LET Expr (Rule B) EQ Expr IN Expr END Main
reduse                                     Expr Main (Rule F)





Example from 3.6.6
Main ::= Expr EOF rule A
Expr ::= NAME rule B
    | CSTINT rule C
    | MINUS CSTINT rule D
    | LPAR Expr RPAR rule E
    | LET NAME EQ Expr IN Expr END rule F
    | Expr TIMES Expr rule G
    | Expr PLUS Expr rule H
    | Expr MINUS Expr rule I



Answer:

let z = (17) in z + 2 * 3 end EOF

Input                                       parse stack                                         Details
------------------------------------------- ----------------------------------------------      -------------------------------------------
let z = (17) in z + 2 * 3 end EOF          Main                                 (Rule A)                                        
let z = (17) in z + 2 * 3 end              LET z EQ (17) IN z + 2 * 3 END       (Rule F)              
3                                          CSTINT                               (Rule C)    
2                                          CSTINT                               (Rule C) 
3*2                                        Expr * Expr                          (Rule G)
z                                          Expr ::= NAME                        (Rule B)
z+2                                        Expr + Expr                          (Rule H)
z+2*3                                      Expr PLUS Expr                       (rule H)
17                                         CSTINT                               (rule C)
(17)                                       LPAR Expr RPAR                       (rule E)
z                                          Expr ::= NAME                        (rule B)



Exercise 3.4 Draw the above derivation as a tree.

Exercise 3.5 Get expr.zip from the book homepage and unpack it. Using a command prompt, generate (1) the lexer and (2) the parser for expressions by running
fslex and fsyacc; then (3) load the expression abstract syntax, the lexer and
parser modules, and the expression interpreter and compilers, into an interactive F#
session (fsi):
fslex --unicode ExprLex.fsl
fsyacc --module ExprPar ExprPar.fsy
fsi -r FSharp.PowerPack.dll Absyn.fs ExprPar.fs ExprLex.fs ^
Parse.fs
Now try the parser on several example expressions, both well-formed and ill-formed
ones, such as these, and some of your own invention:
open Parse;;
fromString "1 + 2 * 3";;
fromString "1-2- 3";;
fromString "1 + -2";;
fromString "x++";;
fromString "1 + 1.2";;
fromString "1 + ";;
fromString "let z = (17) in z + 2 * 3 end";;
fromString "let z = 17) in z + 2 * 3 end";;
fromString "let in = (17) in z + 2 * 3 end";;
fromString "1 + let x=5 in let y=7+x in y+y end + x end";;

Exercise 3.6 Use the expression parser from Parse.fs and the compiler scomp
(from expressions to stack machine instructions) and the associated datatypes from
Expr.fs, to define a function compString : string -> sinstr list
that parses a string as an expression and compiles it to stack machine code.


Exercise 3.7 Extend the expression language abstract syntax and the lexer and
parser specifications with conditional expressions. The abstract syntax should be
If(e1, e2, e3), so modify file Absyn.fs as well as ExprLex.fsl and
file ExprPar.fsy. The concrete syntax may be the keyword-laden F#/ML-style:
if e1 then e2 else e3
or the more light-weight C/C++/Java/C#-style:
e1 ? e2 : e3
Some documentation for fslex and fsyacc is found in this chapter and in Expert
F# [17].